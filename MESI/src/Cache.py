"""
	This file contians the implementation of Cache.
	Cache contains four BlockOfSets, because the cache is 4-way
	set associative. 

	Physical address generated by processor is as:
	--------------------------------------------------
	|20-bit Tag| 6-bit Set | 4-bit Word | 2-bit Byte |
	--------------------------------------------------

	Parameters of the cache:
			16-KB capacity, 64 Bytes block size, 4 Byte word size,
	& 4-way set associative.
"""

import BlockOfSets;

class Cache:

	def __init__(self):
		self._blockZero  = CacheBlock();
		self._blockOne	 = CacheBlock();
		self._blockTwo	 = CacheBlock();
		self._blockThree = CacheBlock();

	"""
		Check if there is an entry corresponding to the 
		address provided(by setId, tag), return a list 
		containing the state of the cacheBlock if present,

		else if the cacheBlock is not present return an 
		empty list(This is a cache misss).

		This module should be called only by the CacheController,
		as an action in response to the bus signals.
	"""
	def GetState(self, setId, tag):
		
		state = self._blockZero.GetData(setId, tag);

		if(len(state) == 1):
			return state;

		state = self._blockOne.GetData(setId, tag);

		if(len(state) == 1):
			return state;

		state = self._blockTwo.GetData(setId, tag);

		if(len(state) == 1):
			return state;

		state = self._blockThree.GetData(setId, tag);

		if(len(state) == 1):
			return state;
		
		# cache miss 
		return [];

	"""
		Read cacheBlock in the corresponding address.	

		This module should be called only when a processor
		issues a write (or) read request. In case of a write
		depending the state we set the state of the cacheBlock
		(This is taken care in CacheController.py module).

		NOTE: In implementation though this is similar to
			  GetState(), here we decrement the lruCount if 
			  there is a hit.
	"""
	def ReadOrWrite(self, setId, tag):

		state = self._blockZero.GetData(setId, tag);
		if(len(state) == 1):
			self._blockZero.DecrementLFU(setId, tag);
			return state;

		state = self._blockOne.GetData(setId, tag);
		if(len(state) == 1):
			self._blockOne.DecrementLFU(setId, tag);
			return state;

		state = self._blockTwo.GetData(setId, tag);
		if(len(state) == 1):
			self._blockTwo.DecrementLFU(setId, tag);
			return state;

		state = self._blockThree.GetData(setId, tag);
		if(len(state) == 1):
			self._blockThree.DecrementLFU(setId, tag);
			return state;
		
		# cache miss 
		return [];

    """
        This function is called only when there is a miss,
        and there is read or write request from processor side.
    """	
	def __GetLfuBlockId(self, setId):
		
		lfuCount = [self._blockZero.GetLfuCount(setId)];
		if(lfuCount[0] == -1):
			return 0;

		lfuCount = lfuCount.append(self._blockOne.GetLfuCount(setId)):
		if(lfuCount[1] == -1):
			return 1;

		lfuCount = lfuCount.append(self._blockTwo.GetLfuCount(setId)):
		if(lfuCount[2] == -1):
			return 2;

		lfuCount = lfuCount.append(self._blockThree.GetLfuCount(setId));
		if(lfuCount[3] == -1):
			return 3;
		
		lfuBlockId = 0;
		for lc in range(1,4):
			if(lfuCount[lfuBlockId] > lfuCount[lc]):
				lfuBlockId = lc;

		return lfuBlockId;
			
	"""
		set the state of cacheBlock, here we reassign 
		or create a new entry, thus start with default
		count for lfu.
	"""
	def SetState(self, setId, tag, stateNew):
		
		state = self._blockZero.GetData(setId, tag);
		if(len(state) == 1):
			self._blockZero.SetValue(setId, tag, stateNew);
			return;

		state = self._blockOne.GetData(setId, tag);
		if(len(state) == 1):
			self._blockOne.SetValue(setId, tag, stateNew);
			return;

		state = self._blockTwo.GetData(setId, tag);
		if(len(state) == 1):
			self._blockTwo.SetValue(setId, tag, stateNew);
			return;

		state = self._blockThree.GetData(setId, tag);
		if(len(state) == 1):
			self._blockThree.SetValue(setId, tag, stateNew);
			return;
		
		lfuBlockId = self.__GetLfuBlockId(setId);
		if(lfuBlockId == 0):
			self._blockZero.SetValue(setId, tag, stateNew);
			
		elif(lfuBlockId == 1):
			self._blockOne.SetValue(setId, tag, stateNew);

		elif(lfuBlockId == 2):
			self._blockTwo.SetValue(setId, tag, stateNew);

		else:
			self._blockThree.SetValue(setId, tag, stateNew);
			

	"""
		here just change the state with out any change in lruCount.
	"""
	def ChangeState(self, setId, tag, stateNew):
		
		state = self._blockZero.GetData(setId, tag);
		if(len(state) == 1):
			self._blockZero.ChangeState(setId, tag, stateNew);
			return;

		state = self._blockOne.GetData(setId, tag);
		if(len(state) == 1):
			self._blockOne.ChangeState(setId, tag, stateNew);
			return;

		state = self._blockTwo.ChangeState(setId, tag);
		if(len(state) == 1):
			self._blockTwo.ChangeState(setId, tag, stateNew);
			return;

		state = self._blockThree.GetData(setId, tag);
		if(len(state) == 1):
			self._blockThree.ChangeState(setId, tag, stateNew);

#------------------ end of class "Cache" ----------------------#
